
{
  "title": "Fix Spotify Home Page Error Loading Media Issue",
  "summary": "This update addresses the 'Error loading media: No Media files found' issue on the Spotify Home Page by correcting how the `fetchMediaError` state is handled in the `spotifyStore.ts` when no media files are initially found. It also ensures that media files are fetched only once when the component mounts.",
  "thoughtProcess": "The issue was occurring because the `fetchMediaError` in `spotifyStore.ts` was being prematurely set to 'No Media files found' regardless of subsequent successful media fetches. To resolve this, the logic for setting `fetchMediaError` has been modified to only set the error if no media files are fetched after the initial API call.  Additionally, a `hasFetchedMedia` state variable was added to `SpotifyHomePage.tsx` to ensure the media is only fetched once on component mount, preventing redundant API calls.  I also reviewed `SpotifyHomePage.tsx` to ensure the UI correctly handles the different states (loading, error, no media, and media available).",
  "changes": [
    {
      "filePath": "src/stores/spotifyStore.ts",
      "action": "modify",
      "newContent": "// /media/eddie/Data/projects/nestJS/nest-modules/project-board-server/apps/project-board-front/src/stores/spotifyStore.ts\n\nimport { map } from 'nanostores';\nimport { showGlobalSnackbar } from './aiEditorStore';\nimport { persistentAtom, mapMediaFileToTrack } from '@/utils';\nimport {\n  Track,\n  Playlist,\n  PaginationPlaylistQueryDto,\n  UpdatePlaylistDto,\n  AddRemoveMediaToPlaylistDto,\n  MediaFileResponseDto,\n  RepeatMode,\n  PlaylistCreationRequest,\n  PaginationMediaQueryDto,\n  FileType,\n  BufferedRange, // New: Import BufferedRange\n} from '@/types';\nimport {\n  fetchPlaylists,\n  fetchPlaylistById,\n  createPlaylist as apiCreatePlaylist,\n  updatePlaylist,\n  deletePlaylist,\n  addMediaToPlaylist,\n  removeMediaFromPlaylist,\n} from '@/api/playlist';\nimport {\n  scanMediaDirectory as apiScanMediaDirectory,\n  fetchMediaFiles as apiFetchAllMediaFiles,\n  transcribeAudio,\n  getTranscription,\n  getSyncTranscription,\n} from '@/api/media';\nimport { authStore } from './authStore'; // Import authStore for login check\nimport { TranscriptionResult, SyncTranscriptionResponse } from '@/types';\n\n// --- Atoms (Non-persistent for transient playback state, persistent for user preferences) ---\n// Playback state should NOT be persistent to avoid browser autoplay issues on refresh.\n// However, the user explicitly requested these to be persistent.\nexport const isPlayingAtom = persistentAtom<boolean>(\n  'spotify:isPlaying',\n  false,\n);\nexport const currentTrackAtom = persistentAtom<Track | null>(\n  'spotify:currentTrack',\n  null,\n);\nexport const progressAtom = persistentAtom<number>('spotify:progress', 0);\nexport const durationAtom = persistentAtom<number>('spotify:duration', 0);\nexport const bufferedAtom = persistentAtom<BufferedRange[]>(\n  'spotify:buffered',\n  [],\n); // New: Buffered ranges atom\nexport const isVideoModalOpenAtom = persistentAtom<boolean>(\n  'spotify:isVideoModalOpen',\n  false,\n);\n\n// User preferences are persistent\nexport const volumeAtom = persistentAtom<number>('spotify:volume', 70); // Persistent\nexport const repeatModeAtom = persistentAtom<RepeatMode>(\n  'spotify:repeatMode',\n  'off',\n); // Persistent\nexport const shuffleAtom = persistentAtom<boolean>('spotify:shuffle', false); // Persistent\n\n// --- Store Interface (for the map part) ---\nexport interface SpotifyStore {\n  queue: Track[];\n  history: Track[];\n  currentPlaylist: Playlist | null;\n  playlists: Playlist[];\n  isLoadingPlaylists: boolean;\n  playlistError: string | null;\n  // General media related state\n  allAvailableMediaFiles: MediaFileResponseDto[];\n  isFetchingMedia: boolean;\n  fetchMediaError: string | null;\n  // Paginated audio files state\n  paginatedAudioFiles: MediaFileResponseDto[];\n  audioPagination: {\n    page: number;\n    pageSize: number;\n    totalPages: number;\n    hasMore: boolean;\n  };\n  isFetchingPaginatedAudio: boolean;\n  fetchPaginatedAudioError: string | null;\n  // Paginated video files state\n  paginatedVideoFiles: MediaFileResponseDto[];\n  videoPagination: {\n    page: number;\n    pageSize: number;\n    totalPages: number;\n    hasMore: boolean;\n  };\n  isFetchingPaginatedVideo: boolean;\n  fetchPaginatedVideoError: string | null;\n  // Media scan state\n  mediaScanPath: string;\n  isScanningMedia: boolean;\n  mediaScanError: string | null;\n  loading: boolean;\n  error: string | null;\n\n  // ADD THESE TRANSCRIPTION PROPERTIES:\n  transcriptionData: TranscriptionResult | null;\n  transcriptionSyncData: SyncTranscriptionResponse | null;\n  isTranscribing: boolean;\n  transcriptionError: string | null;\n}\n\n// --- Initial State (for the map part) ---\nexport const $spotifyStore = map<SpotifyStore>({\n  queue: [],\n  history: [],\n  currentPlaylist: null,\n  playlists: [],\n  isLoadingPlaylists: false,\n  playlistError: null,\n  // General media state\n  allAvailableMediaFiles: [],\n  isFetchingMedia: false,\n  fetchMediaError: null,\n  // Paginated audio state\n  paginatedAudioFiles: [],\n  audioPagination: { page: 1, pageSize: 20, totalPages: 1, hasMore: false },\n  isFetchingPaginatedAudio: false,\n  fetchPaginatedAudioError: null,\n  // Paginated video state\n  paginatedVideoFiles: [],\n  videoPagination: { page: 1, pageSize: 20, totalPages: 1, hasMore: false },\n  isFetchingPaginatedVideo: false,\n  fetchPaginatedVideoError: null,\n  // Media scan state\n  mediaScanPath: '',\n  isScanningMedia: false,\n  mediaScanError: null,\n  loading: false,\n  error: null,\n\n  // ADD THESE TRANSCRIPTION INITIAL STATES:\n  transcriptionData: null,\n  transcriptionSyncData: null,\n  isTranscribing: false,\n  transcriptionError: null,\n});\n\n// --- Actions ---\n\nexport const setLoading = (isLoading: boolean) => {\n  $spotifyStore.setKey('loading', isLoading);\n};\n\nexport const setError = (message: string | null) => {\n  $spotifyStore.setKey('error', message);\n};\n// Add this action to clear transcription data\nexport const clearTranscription = () => {\n  const state = $spotifyStore.get();\n  $spotifyStore.set({\n    ...state,\n    transcriptionData: null,\n    transcriptionSyncData: null,\n    isTranscribing: false,\n    transcriptionError: null,\n  });\n};\n/**\n * Resets all playback-related state to their initial non-playing values.\n * This is useful when stopping playback, closing a modal, or clearing the player.\n */\nexport const resetPlaybackState = () => {\n  isPlayingAtom.set(false);\n  currentTrackAtom.set(null);\n  progressAtom.set(0);\n  durationAtom.set(0);\n  bufferedAtom.set([]);\n  isVideoModalOpenAtom.set(false);\n  $spotifyStore.setKey('loading', false);\n  $spotifyStore.setKey('error', null);\n  clearTranscription(); // Add this line\n};\n\n/**\n * Sets the playback state (playing or paused).\n * This is primarily used by the media element's event handlers in SpotifyAppPage\n * to synchronize the store's `isPlaying` state with the actual media element.\n */\nexport const setPlaying = (status: boolean) => {\n  isPlayingAtom.set(status);\n};\n\n/**\n * Sets the current playback progress in seconds.\n */\nexport const setTrackProgress = (progress: number) => {\n  progressAtom.set(progress);\n};\n\n/**\n * Sets the total duration of the current track in seconds.\n */\nexport const setTrackDuration = (duration: number) => {\n  durationAtom.set(duration);\n};\n\n/**\n * Sets the visibility of the video modal.\n */\nexport const setIsVideoModalOpen = (isOpen: boolean) => {\n  isVideoModalOpenAtom.set(isOpen);\n};\n\n/**\n * Sets the current buffered ranges.\n */\nexport const setBuffered = (ranges: BufferedRange[]) => {\n  bufferedAtom.set(ranges);\n};\n\n/**\n * Plays a specific track and optionally sets up a new queue/history.\n * @param mediaFile The MediaFileResponseDto to play.\n * @param contextTracks All tracks available in the current context (e.g., playlist, album, search results).\n */\nexport const playTrack = (\n  mediaFile: MediaFileResponseDto,\n  contextTracks: Track[],\n) => {\n  const trackToPlay = mapMediaFileToTrack(mediaFile);\n  // Get values from individual atoms\n  const currentTrack = currentTrackAtom.get();\n  const isPlaying = isPlayingAtom.get();\n  const shuffle = shuffleAtom.get(); // Get shuffle from persistent atom\n\n  // If playing the same track, just toggle play/pause\n  if (currentTrack?.id === trackToPlay.id) {\n    isPlayingAtom.set(!isPlaying);\n    return;\n  }\n\n  // Add current track to history before changing\n  if (currentTrack) {\n    $spotifyStore.setKey('history', [\n      ...$spotifyStore.get().history,\n      currentTrack,\n    ]);\n  }\n\n  // Set new current track and build a new queue\n  const trackIndex = contextTracks.findIndex((t) => t.id === trackToPlay.id);\n  let newQueue: Track[] = [];\n  if (trackIndex !== -1) {\n    newQueue = contextTracks.slice(trackIndex + 1);\n    if (shuffle) {\n      newQueue = shuffleArray(newQueue);\n    }\n  }\n\n  // Update individual atoms and map\n  currentTrackAtom.set(trackToPlay);\n  isPlayingAtom.set(true); // Intend to play immediately\n  progressAtom.set(0); // Reset progress for new track\n  durationAtom.set(trackToPlay.duration || 0); // Set initial duration\n  bufferedAtom.set([]); // New: Reset buffered ranges for new track\n\n  // Set video modal visibility based on track type\n  if (trackToPlay.fileType === FileType.VIDEO) {\n    isVideoModalOpenAtom.set(true);\n  } else {\n    isVideoModalOpenAtom.set(false);\n  }\n\n  $spotifyStore.set({\n    ...$spotifyStore.get(), // Keep other map properties\n    queue: newQueue,\n    error: null, // Clear any previous errors\n    loading: true, // Set loading while media prepares\n  });\n};\n\nexport const togglePlayPause = () => {\n  isPlayingAtom.set(!isPlayingAtom.get());\n};\n\nexport const setVolume = (volume: number) => {\n  volumeAtom.set(volume);\n};\n\nexport const toggleShuffle = () => {\n  const state = $spotifyStore.get();\n  const newShuffle = !shuffleAtom.get(); // Toggle the persistent atom\n  shuffleAtom.set(newShuffle);\n\n  let newQueue = [...state.queue];\n\n  if (newShuffle) {\n    newQueue = shuffleArray(newQueue);\n  } else {\n    // If unshuffling, try to restore original order or just keep current order\n    // For simplicity, we'll just keep the current shuffled order if no original order is maintained\n    // A more robust solution would require storing the 'unshuffled' queue.\n  }\n  $spotifyStore.set({ ...state, queue: newQueue });\n};\n\nexport const toggleRepeat = () => {\n  const currentMode = repeatModeAtom.get(); // Get from persistent atom\n  const newMode: RepeatMode = currentMode === 'off'\n    ? 'context'\n    : currentMode === 'context'\n      ? 'track'\n      : 'off';\n  repeatModeAtom.set(newMode); // Set the persistent atom\n};\n\nexport const nextTrack = () => {\n  const state = $spotifyStore.get(); // Get map state\n  const currentTrack = currentTrackAtom.get(); // Get currentTrack from atom\n  const repeatMode = repeatModeAtom.get(); // Get repeatMode from persistent atom\n\n  if (repeatMode === 'track' && currentTrack) {\n    // If repeating current track, just restart it\n    progressAtom.set(0);\n    isPlayingAtom.set(true);\n    // Modal state doesn't change if repeating the same track\n    return;\n  }\n\n  if (state.queue.length > 0) {\n    const [next, ...rest] = state.queue;\n    if (currentTrack) {\n      $spotifyStore.setKey('history', [...state.history, currentTrack]);\n    }\n    currentTrackAtom.set(next);\n    isPlayingAtom.set(true);\n    progressAtom.set(0);\n    durationAtom.set(next.duration || 0);\n    bufferedAtom.set([]); // New: Reset buffered ranges for new track\n\n    // Update video modal state for the next track\n    if (next.fileType === FileType.VIDEO) {\n      isVideoModalOpenAtom.set(true);\n    } else {\n      isVideoModalOpenAtom.set(false);\n    }\n\n    $spotifyStore.set({\n      ...state,\n      queue: rest,\n    });\n  } else if (repeatMode === 'context' && state.currentPlaylist) {\n    // If queue is empty but repeating context, restart from the beginning of the current playlist\n    const firstTrack = state.currentPlaylist.tracks[0];\n    if (firstTrack) {\n      currentTrackAtom.set(firstTrack);\n      isPlayingAtom.set(true);\n      progressAtom.set(0);\n      durationAtom.set(firstTrack.duration || 0);\n      bufferedAtom.set([]); // New: Reset buffered ranges for new track\n\n      // Update video modal state for the first track in playlist\n      if (firstTrack.fileType === FileType.VIDEO) {\n        isVideoModalOpenAtom.set(true);\n      } else {\n        isVideoModalOpenAtom.set(false);\n      }\n\n      $spotifyStore.set({\n        ...state,\n        queue: shuffleArray(state.currentPlaylist.tracks.slice(1)),\n        history: [],\n      });\n    } else {\n      // No tracks in playlist, stop playing\n      resetPlaybackState(); // New: Use resetPlaybackState\n    }\n  } else {\n    // No more tracks and not repeating, stop playing\n    resetPlaybackState(); // New: Use resetPlaybackState\n  }\n};\n\nexport const previousTrack = () => {\n  const state = $spotifyStore.get(); // Get map state\n  const currentTrack = currentTrackAtom.get(); // Get currentTrack from atom\n\n  if (state.history.length > 0) {\n    const previous = state.history[state.history.length - 1];\n    const newHistory = state.history.slice(0, -1);\n    if (currentTrack) {\n      $spotifyStore.setKey('queue', [currentTrack, ...state.queue]);\n    }\n    currentTrackAtom.set(previous);\n    isPlayingAtom.set(true);\n    progressAtom.set(0);\n    durationAtom.set(previous.duration || 0);\n    bufferedAtom.set([]); // New: Reset buffered ranges for new track\n\n    // Update video modal state for the previous track\n    if (previous.fileType === FileType.VIDEO) {\n      isVideoModalOpenAtom.set(true);\n    } else {\n      isVideoModalOpenAtom.set(false);\n    }\n\n    $spotifyStore.set({\n      ...state,\n      history: newHistory,\n    });\n  } else {\n    // If no history, restart current track\n    if (currentTrack) {\n      progressAtom.set(0);\n      isPlayingAtom.set(true);\n      // Modal state doesn't change if restarting the same track\n    } else {\n      resetPlaybackState(); // New: Use resetPlaybackState\n    }\n  }\n};\n\n// Helper for shuffling arrays\nconst shuffleArray = <T>(array: T[]): T[] => {\n  const newArray = [...array];\n  for (let i = newArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n  }\n  return newArray;\n};\n\n// --- Media File Actions ---\n\n/**\n * Fetches media files based on purpose (general, paginated audio, paginated video).\n * @param query Pagination and filter query.\n * @param purpose The intended use of the fetched data.\n * @param reset If true, clears existing data for the purpose before adding new.\n */\nexport const fetchMediaForPurpose = async (\n  query: PaginationMediaQueryDto = {},\n  purpose: 'general' | 'paginatedAudio' | 'paginatedVideo',\n  reset: boolean = false,\n) => {\n  const state = $spotifyStore.get();\n  let currentFiles: MediaFileResponseDto[] = [];\n  let currentPagination = {\n    page: 1,\n    pageSize: 20,\n    totalPages: 1,\n    hasMore: false,\n  };\n\n  // Set loading and error states based on purpose\n  switch (purpose) {\n    case 'general':\n      $spotifyStore.setKey('isFetchingMedia', true);\n      $spotifyStore.setKey('fetchMediaError', null); // Clear any existing error before fetching\n      currentFiles = state.allAvailableMediaFiles;\n\n      break;\n    case 'paginatedAudio':\n      $spotifyStore.setKey('isFetchingPaginatedAudio', true);\n      $spotifyStore.setKey('fetchPaginatedAudioError', null);\n      currentFiles = state.paginatedAudioFiles;\n      currentPagination = state.audioPagination;\n      break;\n    case 'paginatedVideo':\n      $spotifyStore.setKey('isFetchingPaginatedVideo', true);\n      $spotifyStore.setKey('fetchPaginatedVideoError', null);\n      currentFiles = state.paginatedVideoFiles;\n      currentPagination = state.videoPagination;\n      break;\n  }\n\n  try {\n    // Ensure page and pageSize are set for paginated purposes\n    const effectiveQuery = { ...query };\n    // If resetting, ensure page is 1. Otherwise, use current pagination page or query page.\n    if (reset) {\n      effectiveQuery.page = 1;\n    } else if (!effectiveQuery.page) {\n      effectiveQuery.page = currentPagination.page;\n    } else if (effectiveQuery.page < currentPagination.page) {\n      // If fetching a page less than current, it implies a reset to an earlier page\n      reset = true;\n    }\n    if (!effectiveQuery.pageSize)\n      effectiveQuery.pageSize = currentPagination.pageSize;\n\n    const result = await apiFetchAllMediaFiles(effectiveQuery);\n\n    const newItems = result.items.filter(\n      (newItem) =>\n        !currentFiles.some((existingItem) => existingItem.id === newItem.id),\n    );\n\n    const updatedFiles = reset ? newItems : [...currentFiles, ...newItems];\n\n    const newPagination = {\n      page: result.page,\n      pageSize: result.pageSize,\n      totalPages: result.totalPages,\n      hasMore: result.page < result.totalPages,\n    };\n\n    // Update store keys based on purpose\n    switch (purpose) {\n      case 'general':\n        $spotifyStore.setKey('allAvailableMediaFiles', updatedFiles);\n        // If no media files were found, set the fetchMediaError\n        if (updatedFiles.length === 0) {\n          $spotifyStore.setKey('fetchMediaError', 'No Media files found');\n        }\n        break;\n      case 'paginatedAudio':\n        $spotifyStore.setKey('paginatedAudioFiles', updatedFiles);\n        $spotifyStore.setKey('audioPagination', newPagination);\n        break;\n      case 'paginatedVideo':\n        $spotifyStore.setKey('paginatedVideoFiles', updatedFiles);\n        $spotifyStore.setKey('videoPagination', newPagination);\n        break;\n    }\n  } catch (error: any) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Failed to load media files.';\n    showGlobalSnackbar(`Error loading media files: ${errorMessage}`, 'error');\n    switch (purpose) {\n      case 'general':\n        $spotifyStore.setKey('fetchMediaError', errorMessage);\n        break;\n      case 'paginatedAudio':\n        $spotifyStore.setKey('fetchPaginatedAudioError', errorMessage);\n        break;\n      case 'paginatedVideo':\n        $spotifyStore.setKey('fetchPaginatedVideoError', errorMessage);\n        break;\n    }\n  } finally {\n    switch (purpose) {\n      case 'general':\n        $spotifyStore.setKey('isFetchingMedia', false);\n        break;\n      case 'paginatedAudio':\n        $spotifyStore.setKey('isFetchingPaginatedAudio', false);\n        break;\n      case 'paginatedVideo':\n        $spotifyStore.setKey('isFetchingPaginatedVideo', false);\n        break;\n    }\n  }\n};\n\nexport const addExtractedMediaFile = (mediaFile: MediaFileResponseDto) => {\n  const currentFiles = $spotifyStore.get().allAvailableMediaFiles;\n  // Check if the file already exists to prevent duplicates\n  if (!currentFiles.some((file) => file.id === mediaFile.id)) {\n    $spotifyStore.setKey('allAvailableMediaFiles', [\n      ...currentFiles,\n      mediaFile,\n    ]);\n  }\n\n};\n\n\n\nexport const fetchUserPlaylists = async (\n  query?: PaginationPlaylistQueryDto,\n) => {\n  $spotifyStore.setKey('isLoadingPlaylists', true);\n  $spotifyStore.setKey('playlistError', null);\n  try {\n    const result = await fetchPlaylists(query);\n\n    const transformedPlaylists: Playlist[] = result.items.map((p) => ({\n      id: p.id,\n      name: p.name,\n      description: p.description,\n      isPublic: p.isPublic,\n      cover:\n        p.playlistMediaFiles?.[0]?.file?.metadata?.data?.thumbnail ||\n        (p.playlistMediaFiles?.[0]?.file?.fileType === FileType.VIDEO\n          ? '/default-video-cover.png'\n          : '/default-album-art.png'), // Dynamic default cover\n      tracks: p.playlistMediaFiles\n        .filter((pt) => pt.file) // Ensure file exists before mapping\n        .map((pt) => mapMediaFileToTrack(pt.file)),\n      trackCount: p.trackCount || p.playlistMediaFiles.length,\n    }));\n    $spotifyStore.setKey('playlists', transformedPlaylists);\n  } catch (error: any) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Failed to load playlists.';\n    showGlobalSnackbar(`Error loading playlists: ${errorMessage}`, 'error');\n  } finally {\n    $spotifyStore.setKey('isLoadingPlaylists', false);\n  }\n};\n\nexport const loadPlaylistDetails = async (playlistId: string) => {\n  $spotifyStore.setKey('isLoadingPlaylists', true);\n  $spotifyStore.setKey('playlistError', null);\n  try {\n    const p = await fetchPlaylistById(playlistId);\n    const transformedPlaylist: Playlist = {\n      id: p.id,\n      name: p.name,\n      description: p.description,\n      isPublic: p.isPublic,\n      cover:\n        p.playlistMediaFiles?.[0]?.file?.metadata?.data?.thumbnail ||\n        (p.playlistMediaFiles?.[0]?.file?.fileType === FileType.VIDEO\n          ? '/default-video-cover.png'\n          : '/default-album-art.png'), // Dynamic default cover\n      tracks: p.playlistMediaFiles\n        .filter((pt) => pt.file) // Ensure file exists before mapping\n        .map((pt) => mapMediaFileToTrack(pt.file)),\n      trackCount: p.trackCount || p.playlistMediaFiles.length,\n    };\n    $spotifyStore.setKey('currentPlaylist', transformedPlaylist);\n  } catch (error: any) {\n    const errorMessage =\n      error instanceof Error\n        ? error.message\n        : 'Failed to load playlist details.';\n    $spotifyStore.setKey('playlistError', errorMessage);\n    showGlobalSnackbar(\n      `Error loading playlist details: ${errorMessage}`,\n      'error',\n    );\n  } finally {\n    $spotifyStore.setKey('isLoadingPlaylists', false);\n  }\n};\n\n/**\n * Creates a new playlist. This action accepts a frontend-friendly DTO.\n */\nexport const createUserPlaylist = async (payload: PlaylistCreationRequest) => {\n  try {\n    const newPlaylist = await apiCreatePlaylist(payload);\n    showGlobalSnackbar(\n      `Playlist ${newPlaylist.name} created successfully!`,\n      'success',\n    );\n    fetchUserPlaylists();\n    return newPlaylist;\n  } catch (error: any) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Failed to create playlist.';\n    showGlobalSnackbar(`Error creating playlist: ${errorMessage}`, 'error');\n    throw error;\n  }\n};\n\nexport const updateExistingPlaylist = async (\n  playlistId: string,\n  dto: UpdatePlaylistDto,\n) => {\n  try {\n    const updatedPlaylist = await updatePlaylist(playlistId, dto);\n    showGlobalSnackbar(\n      `Playlist ${updatedPlaylist.name} updated successfully!`,\n      'success',\n    );\n    fetchUserPlaylists();\n    if ($spotifyStore.get().currentPlaylist?.id === playlistId) {\n      // Check currentPlaylist from store map\n      loadPlaylistDetails(playlistId);\n    }\n    return updatedPlaylist;\n  } catch (error: any) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Failed to update playlist.';\n    showGlobalSnackbar(`Error updating playlist: ${errorMessage}`, 'error');\n    throw error;\n  }\n};\n\nexport const removePlaylist = async (playlistId: string) => {\n  try {\n    await deletePlaylist(playlistId);\n    showGlobalSnackbar('Playlist deleted successfully!', 'success');\n    fetchUserPlaylists();\n    // If the current track was part of the deleted playlist, reset playback state\n    const currentTrack = currentTrackAtom.get();\n    if (currentTrack && currentTrack.id === playlistId) {\n      // Assuming playlist ID could be used as a track ID in some contexts, though unlikely\n      resetPlaybackState();\n    }\n    // More robust check: if currentTrack is from a playlist, check if that playlist is the deleted one\n    // This would require currentTrack to store its origin playlist ID, which it currently doesn't.\n    // For simplicity, we just clear if the currentTrack ID matches the playlistId.\n  } catch (error: any) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Failed to delete playlist.';\n    showGlobalSnackbar(`Error deleting playlist: ${errorMessage}`, 'error');\n    throw error;\n  }\n};\n\nexport const addMediaToSpecificPlaylist = async (\n  playlistId: string,\n  dto: AddRemoveMediaToPlaylistDto,\n) => {\n  try {\n    await addMediaToPlaylist(playlistId, dto);\n    showGlobalSnackbar('Media added to playlist successfully!', 'success');\n    loadPlaylistDetails(playlistId);\n    fetchUserPlaylists(); // Re-fetch all playlists to update counts/content in library\n  } catch (error: any) {\n    const errorMessage =\n      error instanceof Error\n        ? error.message\n        : 'Failed to add media to playlist.';\n    showGlobalSnackbar(`Error adding media: ${errorMessage}`, 'error');\n    throw error;\n  }\n};\n\nexport const removeMediaFromSpecificPlaylist = async (\n  playlistId: string,\n  mediaFileId: string,\n) => {\n  try {\n    await removeMediaFromPlaylist(playlistId, { mediaFileId });\n    showGlobalSnackbar('Media removed from playlist successfully!', 'success');\n    loadPlaylistDetails(playlistId);\n    fetchUserPlaylists(); // Re-fetch all playlists to update counts/content in library\n  } catch (error: any) {\n    const errorMessage =\n      error instanceof Error\n        ? error.message\n        : 'Failed to remove media from playlist.';\n    showGlobalSnackbar(`Error removing media: ${errorMessage}`, 'error');\n    throw error;\n  }\n};\n\n// =========================================================================\n// Media Scanning Actions\n// =========================================================================\nexport const setMediaScanPath = (path: string) => {\n  $spotifyStore.setKey('mediaScanPath', path);\n};\n\nexport const triggerMediaScan = async (path: string) => {\n  const isLoggedIn = authStore.get().isLoggedIn;\n  if (!isLoggedIn) {\n    showGlobalSnackbar('You must be logged in to scan media.', 'error');\n    return;\n  }\n\n  const state = $spotifyStore.get();\n  if (state.isScanningMedia) return;\n\n  $spotifyStore.set({ ...state, isScanningMedia: true, mediaScanError: null });\n\n  try {\n    // Call the API to scan media directory\n    await apiScanMediaDirectory({ directoryPath: path });\n\n    showGlobalSnackbar(`Scanning directory: ${path}`, 'info');\n\n    // After scan, re-fetch all media and paginated media to reflect changes\n    fetchMediaForPurpose({ page: 1, pageSize: 200 }, 'general', true);\n    fetchMediaForPurpose(\n      { page: 1, pageSize: 20, fileType: FileType.AUDIO },\n      'paginatedAudio',\n      true,\n    );\n    fetchMediaForPurpose(\n      { page: 1, pageSize: 20, fileType: FileType.VIDEO },\n      'paginatedVideo',\n      true,\n    );\n\n    showGlobalSnackbar('Media scan complete!', 'success');\n  } catch (err: any) {\n    const message = err.message || 'Failed to trigger media scan.';\n    $spotifyStore.setKey('mediaScanError', message);\n    showGlobalSnackbar(message, 'error');\n  } finally {\n    $spotifyStore.setKey('isScanningMedia', false);\n  }\n};\n\nexport const loadTranscription = async (fileId: string) => {\n  const state = $spotifyStore.get();\n  $spotifyStore.setKey('isTranscribing', true);\n  $spotifyStore.setKey('transcriptionError', null);\n\n  try {\n    const data = await getTranscription(fileId);\n    $spotifyStore.set({\n      ...state,\n      transcriptionData: data,\n      isTranscribing: false,\n      transcriptionError: null,\n    });\n  } catch (err) {\n    $spotifyStore.set({\n      ...state,\n      isTranscribing: false,\n      transcriptionError:\n        err instanceof Error ? err.message : 'Failed to load transcription',\n    });\n  }\n};\n\nexport const transcribeAudioAction = async (fileId: string) => {\n  const state = $spotifyStore.get();\n  $spotifyStore.setKey('isTranscribing', true);\n  $spotifyStore.setKey('transcriptionError', null);\n\n  try {\n    const data = await transcribeAudio(fileId);\n    $spotifyStore.set({\n      ...state,\n      transcriptionData: data,\n      isTranscribing: false,\n      transcriptionError: null,\n    });\n  } catch (err) {\n    $spotifyStore.set({\n      ...state,\n      isTranscribing: false,\n      transcriptionError:\n        err instanceof Error ? err.message : 'Transcription failed',\n    });\n  }\n};\n\nexport const updateTranscriptionSync = async (\n  fileId: string,\n  currentTime: number,\n) => {\n  const state = $spotifyStore.get();\n  if (!state.transcriptionData) return;\n\n  try {\n    const syncData = await getSyncTranscription(fileId, currentTime);\n    $spotifyStore.setKey('transcriptionSyncData', syncData);\n  } catch (err) {\n    console.error('Failed to sync transcription:', err);\n  }\n};\n",
      "reason": "Modified fetchMediaForPurpose in spotifyStore.ts to handle errors appropriately and avoid prematurely setting fetchMediaError when media files are not initially found. Also cleared fetchMediaError at the beginning of the fetchMediaForPurpose function."
    },
{
      "filePath": "src/pages/spotify/SpotifyHomePage.tsx",
      "action": "modify",
      "newContent": "import React, { useEffect, useState, useCallback, useMemo } from 'react';\nimport {\n  Box,\n  Typography,\n  CircularProgress,\n  Alert,\n  useTheme,\n} from '@mui/material';\nimport { useStore } from '@nanostores/react';\nimport {\n  $spotifyStore,\n  playTrack,\n  fetchMediaForPurpose,\n  isPlayingAtom,\n  currentTrackAtom,\n} from '@/stores/spotifyStore';\nimport { MediaFileResponseDto, FileType } from '@/types';\nimport { mapMediaFileToTrack } from '@/utils/mediaUtils';\nimport { authStore } from '@/stores/authStore';\nimport SongList from '@/components/ui/SongList';\nimport VideoList from '@/components/ui/VideoList';\nimport { showGlobalSnackbar } from '@/stores/aiEditorStore';\n\n\ninterface SpotifyHomePageProps {\n  // No specific props for now, just static content\n}\n\nconst SpotifyHomePage: React.FC<SpotifyHomePageProps> = () => {\n  const theme = useTheme();\n  const { isLoggedIn } = useStore(authStore); // Get login status\n  const { allAvailableMediaFiles, isFetchingMedia, fetchMediaError } = useStore($spotifyStore);\n\n  // Directly get isPlaying and currentTrack from their respective atoms\n  const isPlaying = useStore(isPlayingAtom);\n  const currentTrack = useStore(currentTrackAtom);\n  const [favoriteSongs, setFavoriteSongs] = useState<string[]>([]);\n  const [favoriteVideos, setFavoriteVideos] = useState<string[]>([]);\n  const [hasFetchedMedia, setHasFetchedMedia] = useState(false);\n\n  useEffect(() => {\n    // Fetch media files when the component mounts if not already fetched\n    // Use 'general' purpose to populate allAvailableMediaFiles, with reset: true\n    if (!hasFetchedMedia && !isFetchingMedia) {\n      fetchMediaForPurpose({ page: 1, pageSize: 200 }, 'general', false);\n      setHasFetchedMedia(true);\n    }\n  }, [hasFetchedMedia, isFetchingMedia]);\n\n  // Filter for audio files\n  const playableAudioTracks: MediaFileResponseDto[] = allAvailableMediaFiles.filter(media => media.fileType === FileType.AUDIO);\n  // Filter for video files\n  const playableVideoTracks: MediaFileResponseDto[] = allAvailableMediaFiles.filter(media => media.fileType === FileType.VIDEO);\n\n  const handlePlayAudio = useCallback((song: any) => {\n    playTrack(song, playableAudioTracks.map(mapMediaFileToTrack));\n  }, [playableAudioTracks]);\n\n  const handlePlayVideo = useCallback((video: any) => {\n    playTrack(video, playableVideoTracks.map(mapMediaFileToTrack));\n  }, [playableVideoTracks]);\n\n  const toggleFavoriteSong = useCallback((songId: string) => {\n    setFavoriteSongs(prev =>\n      prev.includes(songId) ? prev.filter(id => id !== songId) : [...prev, songId]\n    );\n  }, []);\n\n  const toggleFavoriteVideo = useCallback((videoId: string) => {\n    setFavoriteVideos(prev =>\n      prev.includes(videoId) ? prev.filter(id => id !== videoId) : [...prev, videoId]\n    );\n  }, []);\n\n  const handleSongAction = (action: string, song: any) => {\n    showGlobalSnackbar(`Action: ${action} on song ${song.title}`, 'info');\n    // Implement other actions like edit, delete, download, etc.\n  };\n\n  const handleVideoAction = (action: string, video: any) => {\n    showGlobalSnackbar(`Action: ${action} on video ${video.title}`, 'info');\n    // Implement other actions like trailer, watchlist, download, etc.\n  };\n\n\n  const audioList = useMemo(() => {\n    return playableAudioTracks.map((mediaFile) => {\n      const track = mapMediaFileToTrack(mediaFile);\n      return {\n        id: track.id,\n        title: track.title,\n        artist: track.artist,\n        album: track.album,\n        duration: track.duration,\n        genre: ['Opm', 'Classic'],\n        isFavorite: favoriteSongs.includes(track.id),\n        thumbnail: track.coverArt,\n        year: 2023,\n      };\n    });\n  }, [playableAudioTracks, favoriteSongs]);\n\n  const videoList = useMemo(() => {\n    return playableVideoTracks.map((mediaFile) => {\n      const track = mapMediaFileToTrack(mediaFile);\n      return {\n        id: track.id,\n        title: track.title,\n        description: 'description',\n        duration: 200,\n        thumbnail: track.coverArt,\n        genre: ['Action', 'Adventure'],\n        isFavorite: favoriteVideos.includes(track.id),\n        year: 2013,\n        rating: 4.2,\n      };\n    });\n  }, [playableVideoTracks, favoriteVideos]);\n\n  if (isFetchingMedia) {\n    return (\n      <Box className=\"flex justify-center items-center h-full\">\n        <CircularProgress size={40} />\n        <Typography\n          variant=\"h6\"\n          sx={{ ml: 2, color: theme.palette.text.secondary }}\n        >\n          Loading media files...\n        </Typography>\n      </Box>\n    );\n  }\n\n  const noPlayableMedia = playableAudioTracks.length === 0 && playableVideoTracks.length === 0;\n\n  if (fetchMediaError) {\n    return (\n      <Alert severity=\"error\">Error loading media: {fetchMediaError}</Alert>\n    );\n  }\n\n  if (noPlayableMedia) {\n    return (\n      <Alert severity=\"info\">\n        No playable audio or video files found. Upload some via the AI Editor or\n        backend.\n      </Alert>\n    );\n  }\n\n  return (\n    <Box>\n      <Typography variant=\"h4\" sx={{ fontWeight: 'bold', mb: 3 }}>\n        Good evening\n      </Typography>\n\n      <Typography variant=\"h5\" sx={{ fontWeight: 'bold', mt: 4, mb: 2 }}>\n        All Available Audio Tracks\n      </Typography>\n      <SongList\n        songs={audioList}\n        onPlay={handlePlayAudio}\n        onFavorite={toggleFavoriteSong}\n        onAction={handleSongAction}\n      />\n\n      <Typography variant=\"h5\" sx={{ fontWeight: 'bold', mt: 4, mb: 2 }}>\n        All Available Video Tracks\n      </Typography>\n      <VideoList\n        videos={videoList}\n        onPlay={handlePlayVideo}\n        onFavorite={toggleFavoriteVideo}\n        onAction={handleVideoAction}\n      />\n    </Box>\n  );\n};\n\nexport default SpotifyHomePage;\n"
    }
  ]
}

