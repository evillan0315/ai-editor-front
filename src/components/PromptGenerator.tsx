import React, { useState, useEffect } from 'react';
import { useStore } from '@nanostores/react';
import {
  Button,
  TextField,
  Box,
  Typography,
  CircularProgress,
  Alert,
  Paper,
  InputAdornment,
  IconButton,
  useTheme,
  Autocomplete,
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import {
  aiEditorStore,
  setLoading,
  setError,
  setInstruction,
  setScanPathsInput,
  clearState,
  setLastLlmResponse,
  setCurrentDiff,
  setAppliedMessages,
  setOpenedFile,
} from '@/stores/aiEditorStore';
import { authStore } from '@/stores/authStore';
import { fileTreeStore, fetchFiles } from '@/stores/fileTreeStore';
import { INSTRUCTION, ADDITIONAL_INSTRUCTION_EXPECTED_OUTPUT } from '@/constants';
import { generateCode, LlmGeneratePayload } from '@/api/llm';
import { ModelResponse } from '@/types';
import FilePickerDialog from '@/components/FilePickerDialog';

const PromptGenerator: React.FC = () => {
  const {
    instruction,
    loading,
    error,
    currentProjectPath,
    scanPathsInput,
    applyingChanges,
    isFetchingFileContent,
  } = useStore(aiEditorStore);
  const { isLoggedIn } = useStore(authStore);
  const { flatFileList } = useStore(fileTreeStore);
  const theme = useTheme();

  const [projectInput, setProjectInput] = useState<string>(
    currentProjectPath || import.meta.env.VITE_BASE_DIR || '',
  );
  const [isPickerDialogOpen, setIsPickerDialogOpen] = useState(false);

  useEffect(() => {
    // Initialize projectInput from store or env on mount
    if (currentProjectPath && projectInput !== currentProjectPath) {
      setProjectInput(currentProjectPath);
    }
    if (!projectInput && import.meta.env.VITE_BASE_DIR) {
      setProjectInput(import.meta.env.VITE_BASE_DIR);
      aiEditorStore.setKey('currentProjectPath', import.meta.env.VITE_BASE_DIR);
    }
  }, [currentProjectPath, projectInput]);

  const handleInstructionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setInstruction(event.target.value);
  };

  const handleScanPathsInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setScanPathsInput(event.target.value);
  };

  const handleProjectInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setProjectInput(event.target.value);
  };

  const handleLoadProject = () => {
    if (!projectInput) return;
    aiEditorStore.setKey('currentProjectPath', projectInput);
    setError(null);
    setLastLlmResponse(null); // Clear previous response when loading new project
    setAppliedMessages([]);
    setCurrentDiff(null, null);
    setOpenedFile(null); // Clear opened file when loading new project
    // Optionally refetch file tree for the new project root
    fetchFiles(
      projectInput,
      scanPathsInput
        .split(',')
        .map((s) => s.trim())
        .filter(Boolean),
    );
  };

  const handleGenerateCode = async () => {
    if (!instruction) {
      setError('Please provide instructions for the AI.');
      return;
    }
    if (!isLoggedIn) {
      setError('You must be logged in to use the AI Editor.');
      return;
    }
    if (!currentProjectPath) {
      setError('Please load a project first by entering a path above.');
      return;
    }

    setLoading(true);
    setError(null);
    setLastLlmResponse(null); // Clear previous response
    setCurrentDiff(null, null); // Clear any previous diff
    setAppliedMessages([]);
    setOpenedFile(null); // Close opened file when new generation starts

    try {
      const parsedScanPaths = scanPathsInput
        .split(',')
        .map((s) => s.trim())
        .filter((s) => s !== '');

      const payload: LlmGeneratePayload = {
        userPrompt: instruction,
        projectRoot: currentProjectPath,
        projectStructure: '', // This is generated by the backend
        relevantFiles: [], // This is gathered by the backend
        additionalInstructions: INSTRUCTION,
        expectedOutputFormat: ADDITIONAL_INSTRUCTION_EXPECTED_OUTPUT,
        scanPaths: parsedScanPaths,
      };

      const aiResponse: ModelResponse = await generateCode(payload);
      console.log(aiResponse, 'aiResponse');
      setLastLlmResponse(aiResponse); // Store the full structured response
    } catch (err) {
      setError(`Failed to generate code: ${err instanceof Error ? err.message : String(err)}`);
    } finally {
      setLoading(false);
    }
  };

  // Autocomplete options: relative paths from flatFileList
  const scanPathAutocompleteOptions = React.useMemo(() => {
    if (!currentProjectPath) return [];
    const normalizedProjectRoot = currentProjectPath.replace(/\\/g, '/');
    const options = flatFileList
      .map((entry) => {
        const fullPath = entry.filePath.replace(/\\/g, '/');
        return fullPath.startsWith(normalizedProjectRoot + '/')
          ? fullPath.substring(normalizedProjectRoot.length + 1)
          : fullPath === normalizedProjectRoot
            ? '.'
            : null; // Exclude paths outside project root
      })
      .filter((p): p is string => p !== null && p !== ''); // Filter out nulls and empty strings

    // Add default options if not present
    const defaultPaths = ['src', 'package.json', 'README.md'];
    defaultPaths.forEach((dp) => {
      if (!options.includes(dp)) {
        options.push(dp);
      }
    });
    return Array.from(new Set(options)).sort(); // Ensure unique and sorted
  }, [flatFileList, currentProjectPath]);

  const handleScanPathAutocompleteChange = (
    _event: React.SyntheticEvent,
    newValue: string | null,
  ) => {
    if (newValue) {
      const currentPaths = scanPathsInput
        .split(',')
        .map((p) => p.trim())
        .filter(Boolean);
      if (!currentPaths.includes(newValue)) {
        const updatedPaths = [...currentPaths, newValue].join(',');
        setScanPathsInput(updatedPaths);
      }
    }
  };

  const handleFilePickerDialogSelect = (selectedRelativePaths: string[]) => {
    const currentPaths = new Set(
      scanPathsInput
        .split(',')
        .map((p) => p.trim())
        .filter(Boolean),
    );
    selectedRelativePaths.forEach((p) => currentPaths.add(p));
    setScanPathsInput(Array.from(currentPaths).join(','));
  };

  return (
    <Paper
      elevation={2}
      sx={{
        p: 2,
        flexGrow: 1,
        bgcolor: theme.palette.background.paper,
      }}
    >
      <Box className="mb-6 flex gap-4 items-center flex-wrap">
        <TextField
          label="Project Root Path"
          value={projectInput}
          onChange={handleProjectInputChange}
          placeholder="e.g., /home/user/my-project"
          disabled={loading || applyingChanges || isFetchingFileContent}
          sx={{ flexGrow: 1 }}
          size="small"
          InputLabelProps={{ style: { color: theme.palette.text.secondary } }}
          InputProps={{ style: { color: theme.palette.text.primary } }}
        />
        <Button
          variant="contained"
          color="primary"
          onClick={handleLoadProject}
          disabled={loading || !projectInput || applyingChanges || isFetchingFileContent}
          sx={{ flexShrink: 0 }}
        >
          Load Project
        </Button>
        <Button
          variant="outlined"
          color="secondary"
          onClick={clearState}
          disabled={loading || applyingChanges || isFetchingFileContent}
          sx={{ flexShrink: 0 }}
        >
          Clear All
        </Button>
      </Box>

      {currentProjectPath && (
        <Box
          className="mb-6 p-4 border rounded-md"
          sx={{
            borderColor: theme.palette.divider,
            bgcolor: theme.palette.background.default,
          }}
        >
          <Typography
            variant="h6"
            className="!font-semibold"
            sx={{ color: theme.palette.text.primary }}
          >
            Current Project Root:
            <span style={{ color: theme.palette.primary.main }}> {currentProjectPath}</span>
          </Typography>
          <Typography variant="body2" sx={{ color: theme.palette.text.secondary }} className="mt-2">
            AI will scan paths specified below within this project root.
          </Typography>
        </Box>
      )}

      <Autocomplete
        freeSolo
        options={scanPathAutocompleteOptions}
        value={scanPathsInput}
        onInputChange={(_event, newInputValue) => {
          setScanPathsInput(newInputValue);
        }}
        onChange={handleScanPathAutocompleteChange}
        disabled={
          loading || !isLoggedIn || !currentProjectPath || applyingChanges || isFetchingFileContent
        }
        renderInput={(params) => (
          <TextField
            {...params}
            label="Scan Paths (comma-separated relative paths)"
            placeholder="e.g., src/components,package.json,README.md"
            fullWidth
            margin="normal"
            helperText="Paths where the AI should focus its analysis for project structure and relevant files (relative to project root)."
            InputLabelProps={{ style: { color: theme.palette.text.secondary } }}
            InputProps={{
              ...params.InputProps,
              style: { color: theme.palette.text.primary },
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton
                    onClick={() => setIsPickerDialogOpen(true)}
                    edge="end"
                    disabled={
                      loading ||
                      !isLoggedIn ||
                      !currentProjectPath ||
                      applyingChanges ||
                      isFetchingFileContent
                    }
                    sx={{ color: theme.palette.text.secondary }}
                  >
                    <AddIcon />
                  </IconButton>
                  {params.InputProps.endAdornment}
                </InputAdornment>
              ),
            }}
          />
        )}
      />

      <FilePickerDialog
        open={isPickerDialogOpen}
        onClose={() => setIsPickerDialogOpen(false)}
        onSelect={handleFilePickerDialogSelect}
        currentScanPaths={scanPathsInput
          .split(',')
          .map((s) => s.trim())
          .filter(Boolean)}
      />

      <TextField
        label="AI Instructions (User Prompt)"
        multiline
        rows={6}
        value={instruction}
        onChange={handleInstructionChange}
        placeholder="e.g., Implement a new user authentication module with JWT. Include login and register endpoints."
        disabled={
          loading || !isLoggedIn || !currentProjectPath || applyingChanges || isFetchingFileContent
        }
        fullWidth
        margin="normal"
        InputLabelProps={{ style: { color: theme.palette.text.secondary } }}
        InputProps={{ style: { color: theme.palette.text.primary } }}
      />

      <Button
        variant="contained"
        color="success"
        onClick={handleGenerateCode}
        disabled={
          loading ||
          !instruction ||
          !isLoggedIn ||
          !currentProjectPath ||
          applyingChanges ||
          isFetchingFileContent
        }
        sx={{ mt: 3, py: 1.5, px: 4, fontSize: '1.05rem' }}
      >
        {loading ? <CircularProgress size={20} color="inherit" sx={{ mr: 1 }} /> : null}
        Generate/Modify Code
      </Button>
      {error && (
        <Alert severity="error" sx={{ mt: 3 }}>
          {error}
        </Alert>
      )}
    </Paper>
  );
};

export default PromptGenerator;
